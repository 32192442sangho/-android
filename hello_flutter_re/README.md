## 다트에는 JIT(Just In Tim) 및 AOT(Ahead Of Time) 컴파일러 두종류로 작동한다
##소스코드 출처: 코드 팩토리의 플러터 프로그래밍
#### https://github.com/codefactory-co/golden-rabbit-flutter-novice
####위젯은 플로터의 객체
####195, controller는 위젯 제어(외부와 통신하는 클래스)
####195, 안들이드 설정값은 AndroidManifext.xml 아이폰 설정값은 Info.plist에 있다
####196, 버튼은 콜백함수를 실행
####200, 위젯은 상태, 무상태 두가지 있음. 상태위젯은 setstate()가 추가
####221, 스타일(안드) material(애플) Cupertino
####223, 배리어(barrier) 흐림처리
####230, 설정객체는 of(context)이고 디바이스에 의존한다. 예를 들면 medioQuery는 스크린크기 정보를 준다.
####255, 디바이스의 움직임을 측정하려면 정규화가 필요하다
#### 이 정규화를 지원하는 패키지로는 shake, sensor_plus가 있다.
####257, 플러터가 공식적으로 추천하는 디렉토리명: const, screen, component, model
####260, RootScreen은 최상위 상태위젯이다.
####264, vync에서 v는 vertical 수직방향이다. h는 horizon으로 수평방향이다.
####271, SettingScreen 위젯은 콜백함수의 설정값을 지정한다
####277, 리스너는 옵저버패턴으로 IIFE와 반대되는 Watcher(상태 변경시 실행) 개념이다
#### 보통 제너레이터와 개념적으로 일치
####278, UX는 사용자경험으로 자이로스코프를 이용해 극대화
####281, 동영상플레이어는 HomeScreen이 VideoPlayer로 전환
####287, 이미지처리는 갤러리 권한이 필요. 이에따라 두버전용 설정값 코딩
####318, 무상태위젯의 변경없음 현상은 컨트롤러의 리스너를 통해 setState()를 호출함으로서 해결
####320, Position위젯과 Align위젯으로 정렬
####325, late CameraController에서 late는 Lazy Loding을 의미한다.
####327, WebRTC는 영상통화 구현. 아고라API
#### 즉 초기화를 나중으로 미룬다.
#### const a = () {}는 실행즉시 a객체가 생성되는 것이고, late는 선언은 되었지만 메모리 할당은 이뤄지지 않은 상태
#### 따라서 async ~ await controller.initialize()로 반드시 초기화 해줘야 사용 가능
####327, 웹RTC는 중계용 서버(개념적으로 크로스 엔티티) 필요. 이것이 시그널링 서버이다
####327, CameraPreview 위젯을 사용하려면 CameraController를 입력해야 한다.
####327, 시그널링서버는 커스텀 가능하다. 하지만 아고라를 사용해도 된다.
####318, 네비게이션은 스택 구조이다. 스택은 LIFO (Last In First Out)
####329, 플러터는 네비게이션 스택의 가장 위에 위치한 위젯을 화면으로 보여준다.
####330, 카메라와 마이크 사용하려면 권한 설정을 해야한다.
####336, 카메라와 마이크 권한은 사용자에게 request() 함수를 써서 이용 허가를 꼭 받아야만 한다.
####336, PermissionStatus 클래스에서 limited는 아이폰에서만 해당하는 상태
#### late(뒤에 =없어야함), final vs const(뒤에 =있어야함)의 구조. 즉 late 이후에 변경불가상태로 정하는 것이 final이다.
####347, Future는 어플이 다운됐을 때 생성되는 것이 아니라 그 화면이 렌더리욀 때 빌드되는 것.
#### 보통 디바이스에 의존적인 객체생성에 사용
####348, 캐싱은 일시적으로 데이터를 저장하고 기억함. 캐싱은 화면 깜박임 막음.
#### 이를 위해, snapshot.hasData를 사용해서 로딩상태 인지.
####355, 스택구조이므로 뒤로가기는 pop()을 사용하면 구현가능
####356, engine!에서 !는 engine이 null일 경우 작동하지 말라는 표시

## 생성패턴 종류
#### 추상 팩토리 패턴 : 기능만 정의
#### 빌더 패턴 : return 생성자
#### 팩토리 메소드 패턴: of(context)
#### 프로토타입 패턴: clone
#### 싱글턴 채턴: static 생성자

## 언어별 객체구분
#### 파이썬 oop:속성 & 메소드 < 구상클래스 > 컬랙션 {} [] ()
####          :메소드 < 추상클래스 :
#### 파이썬 FP: 상태 & 람다함수 < 함수 < 모듈
#### 쿼리: 스키마 + 로우 < 테이블 < 데이터베이스
#### 리액트: 상태 & 이벤트(콜백함수) < 컴포넌트 < 컨테이너 < 페이지
#### 플러터: 상태 & setState() < 상태위젯 < 스크린
####        이벤트(콜백함수) < 무상태위젯

## 람다함수의 표기법
#### 자바: () -> {}
#### 자바스크립트: () => {}
#### 파이썬: lambda: x
#### 플러터: () {}

## 자료구조의 종류 horizon 인덱스 [], (), 키{}
#### vertical 스택(순서존재), 힙(랜덤)

